---
layout: post
title: "有序容器"
date: 2020-06-04
description: " 序容器的元素是在插入容器后就被按照某种规则自动排序，所以是“有序”的。C++ 的有序容器使用的是树结构，通常是红黑树——有着最好查找性能的二叉树 "
tag: C++实战笔记
---

{% include JB/setup %}
*  目录
{:toc}

## 有序容器

### 有序容器和无序容器的区别

在定义容器的时候必须要指定 key 的比较函数。只不过这个函数通常是默认的 less，表示小于关系，不用特意写出来

### 解决自定义类型比较排序

解决这个问题有两种办法：一个是重载“<”，另一个是自定义模板参数

1. 自定义类中计算机没有比较大小的概念，要重载“<”操作符，就可以放在容器中排序了
```c++
    bool operator<(const Point& a, const Point& b)
    {
        return a.x < b.x;            // 自定义比较运算
    }

    set<Point> s;                    // 现在就可以正确地放入有序容器
    s.emplace(7);
    s.emplace(3);
```

2. 编写专门的函数对象或者 lambda 表达式，然后在容器的模板参数里指定
```c++
    set<int> s = {7, 3, 9};           // 定义集合并初始化3个元素

    for(auto& x : s) {                // 范围循环输出元素
        cout << x << ",";              // 从小到大排序，3,7,9
    }   

    auto comp = [](auto a, auto b)  // 定义一个lambda，用来比较大小
    {   
        return a > b;                // 定义大于关系
    };  

    set<int, decltype(comp)> gs(comp)  // 使用decltype得到lambda的类型

    std::copy(begin(s), end(s),          // 拷贝算法，拷贝数据
            inserter(gs, gs.end()));  // 使用插入迭代器

    for(auto& x : gs) {                // 范围循环输出元素
        cout << x << ",";                // 从大到小排序，9,7,3
    }  
```

### 使用环境

集合关系就用 set，关联数组就用 map

有序容器在插入的时候会自动排序，所以就有隐含的插入排序成本，当数据量很大的时候，内部的位置查找、树旋转成本可能会比较高

如果你需要实时插入排序，那么选择 set/map 是没问题的。如果是非实时，那么最好还是用 vector，全部数据插入完成后再一次性排序，效果肯定会更好