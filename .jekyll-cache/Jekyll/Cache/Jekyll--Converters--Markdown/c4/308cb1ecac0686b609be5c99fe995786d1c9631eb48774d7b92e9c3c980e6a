I"<h2 id="数组">数组</h2>
<p>Array | -
——– | —
Java,C++ | int a[100]
Python | list = []
JavaScript | let x = [1,2,3]</p>

<h3 id="时间复杂度">时间复杂度</h3>
<p>方法 | 复杂度
——– | —
prepend	| O(n)
append | O(1)
lookup | O(1)
insert | O(n)
delete | O(n)</p>

<h3 id="成员函数">成员函数</h3>

<ul>
  <li>元素访问
    <ul>
      <li>at 访问指定元素，同时进行越界检查</li>
      <li>operator[] 访问指定的元素</li>
      <li>front 访问第一个元素</li>
      <li>back 访问最后一个元素</li>
      <li>data 返回指向内存中数组第一个元素的指针</li>
    </ul>
  </li>
  <li>迭代器
    <ul>
      <li>begin 返回容器第一个元素的迭代器</li>
      <li>end 返回指向容器尾端的迭代器</li>
      <li>rbegin 返回指向容器最后元素的逆向迭代器</li>
      <li>rend 返回指向前端的逆向迭代器</li>
    </ul>
  </li>
  <li>容量
    <ul>
      <li>empty 检查容器是否为空</li>
      <li>size 返回容纳元素数</li>
      <li>max_size 返回可容纳的最大元素数</li>
    </ul>
  </li>
  <li>操作
    <ul>
      <li>fill 以指定值填充容器</li>
      <li>swap 交换内容</li>
    </ul>
  </li>
</ul>

<h2 id="链表">链表</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LinkedList</span> <span class="p">{</span>
	<span class="n">Node</span> <span class="n">head</span><span class="p">;</span> <span class="c1">//head of list</span>
	<span class="cm">/* Linked list Node*/</span>
	<span class="k">class</span> <span class="nc">Node</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
		<span class="n">Node</span> <span class="n">next</span><span class="p">;</span>
		<span class="n">Node</span> <span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span> <span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="p">;}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="时间复杂度-1">时间复杂度</h3>
<p>方法 | 复杂度
——– | —
prepend | O(1)
append | O(1)
lookup | O(n)
insert | O(1)
delete | O(1)</p>

<h3 id="成员函数-1">成员函数</h3>

<ul>
  <li>元素访问
    <ul>
      <li>front 访问第一个元素</li>
      <li>back 访问最后一个元素</li>
    </ul>
  </li>
  <li>迭代器
    <ul>
      <li>begin 返回指向容器第一元素的迭代器</li>
      <li>end 返回指向容器尾端的迭代器</li>
      <li>rbegin 返回指向容器尾端的迭代器</li>
      <li>rend 返回指向前端的逆向迭代器</li>
    </ul>
  </li>
  <li>容量
    <ul>
      <li>empty 检查容器是否为空</li>
      <li>size 返回容纳的元素数</li>
      <li>max_size 返回可容纳的最大元素数</li>
    </ul>
  </li>
  <li>修改器
    <ul>
      <li>clear 清除内容</li>
      <li>insert 插入元素</li>
      <li>emplace 原位构造元素</li>
      <li>erase 擦除元素</li>
      <li>push_back 将元素添加到容器末尾</li>
      <li>emplace_back 在容器末尾就地构造元素</li>
      <li>pop_back 移除末元素</li>
      <li>push_front 插入元素到容器起始</li>
      <li>emplace_front 在容器头部就地构造元素</li>
      <li>pop_front 移除首元素</li>
      <li>resize 改变容器中可存储元素的个数</li>
      <li>swap 交换内容</li>
    </ul>
  </li>
  <li>操作
    <ul>
      <li>merge 合并二个已经排序列表</li>
      <li>splice 从另一个list中移动元素</li>
      <li>remove/remove_if 移除满足特定标准的元素</li>
      <li>reverse 将该链表的所有元素的顺序反转</li>
      <li>unique 删除连续的重复元素</li>
      <li>sort 对元素进行排序</li>
    </ul>
  </li>
</ul>

<h3 id="扩展">扩展</h3>

<ul>
  <li>
    <p>跳表</p>

    <ul>
      <li>时间复杂度
        <ul>
          <li>
            <p>跳表查询的时间复杂度分析：</p>

            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n/2、n/4、n/8、第k级索引结点的个数就是n/(2^k) 假设索引有h级，最高级的索引有2个结点。
n/(2^h) = 2，从而求得 h = log2(n) - 1
</code></pre></div>            </div>
          </li>
          <li>
            <p>时间复杂度 O(logn)</p>
          </li>
        </ul>
      </li>
      <li>优化
        <ul>
          <li>升维 ：空间换时间</li>
        </ul>
      </li>
      <li>应用
        <ul>
          <li>LRU Cache - Linked list: LRU 缓存机制</li>
          <li>Redis - Skip LIst</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="栈">栈</h2>
<p>1.Stack：先入后出；添加、删除皆为O(1)</p>

<p>2.查询为 O(n)</p>

<h3 id="时间复杂度-2">时间复杂度</h3>
<p>方法 | 复杂度
——– | —
Access | O(n)
Search | O(n)
Insertion | O(1)
Deletion | O(1)</p>
<h3 id="成员函数-2">成员函数</h3>

<ul>
  <li>元素访问
    <ul>
      <li>top 访问栈顶元素</li>
    </ul>
  </li>
  <li>容量
    <ul>
      <li>empty 检查底层的容器是否为空</li>
      <li>size 返回容纳的元素数</li>
    </ul>
  </li>
  <li>修改器
    <ul>
      <li>push 向栈顶插入元素</li>
      <li>emplace 于顶原位构造元素</li>
      <li>pop 删除栈顶元素</li>
      <li>swap 交换内容</li>
    </ul>
  </li>
</ul>

<h2 id="队列">队列</h2>
<p>1.Queue：先入先出；添加、删除皆为O(1)</p>

<p>2.查询为 O(n)</p>

<h3 id="时间复杂度-3">时间复杂度</h3>
<p>方法 | 复杂度
——– | —
Access | O(n)
Search | O(n)
Insertion | O(1)
Deletion | O(1)</p>

<h3 id="成员函数-3">成员函数</h3>

<ul>
  <li>元素访问
    <ul>
      <li>front 访问第一个元素</li>
      <li>back 访问最后一个元素</li>
    </ul>
  </li>
  <li>容量
    <ul>
      <li>empty 检查底层的容器是否为空</li>
      <li>size 返回容纳的元素数</li>
    </ul>
  </li>
  <li>修改器
    <ul>
      <li>push 像队列尾部插入元素</li>
      <li>emplace 于尾部原位构造元素</li>
      <li>pop 删除栈顶元素</li>
      <li>swap 交换内容</li>
    </ul>
  </li>
</ul>

<h3 id="扩展-1">扩展</h3>

<ul>
  <li>
    <p>双端队列</p>

    <ul>
      <li>简单理解：两端可以进出的</li>
      <li>插入和删除都是O(1)操作</li>
      <li>QueueDeque - double ended queue</li>
    </ul>
  </li>
  <li>
    <p>优先队列</p>

    <ul>
      <li>插入操作：O(1)</li>
      <li>取出操作：O(logN) - 按照元素的优先级取出</li>
      <li>底层具体实现的数据结构较为多样和复杂：heap、bst(二叉搜索树etc)、treap</li>
    </ul>
  </li>
</ul>

:ET